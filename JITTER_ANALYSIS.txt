=== JITTER ROOT CAUSE ANALYSIS ===

EXECUTIVE SUMMARY
=================
RangedEnemy: NO JITTER after teleport
BasicEnemy/TankEnemy: JITTER after teleport

ROOT CAUSE:
RangedEnemy bypasses NavigationAgent3D completely.
BasicEnemy/TankEnemy use NavigationAgent3D.
After 3-second force_direct_movement, they fall back to nav agent.
NavigationAgent3D state is corrupted after teleport.
Result: JITTER.

THREE CRITICAL DIFFERENCES
==========================

DIFFERENCE #1: _should_update_navigation_path() Override
---------
RangedEnemy.gd Lines 49-51:
  func _should_update_navigation_path() -> bool:
      return false  # NEVER update navigation paths

BaseEnemy.gd Lines 160-162 (default):
  func _should_update_navigation_path() -> bool:
      return move_speed < 4.0

IMPACT:
  RangedEnemy (2.0 speed): NavigationAgent3D NEVER gets updated
  BasicEnemy (3.0 speed): NavigationAgent3D updated every 0.3 seconds
  TankEnemy (1.5 speed): NavigationAgent3D updated every 0.3 seconds

DIFFERENCE #2: Movement Calculation Method
-----------
RangedEnemy.gd Lines 123-129 (DIRECT CALCULATION):
  var direction = global_position.direction_to(target_player.global_position)
  direction.y = 0
  direction = direction.normalized()
  var target_velocity = direction * move_speed
  velocity = velocity.lerp(target_velocity, acceleration * delta)

No NavigationAgent3D dependency. Pure math.

BaseEnemy.handle_movement() Lines 210-218 (NAV AGENT DEPENDENT):
  var next_path_position = nav_agent.get_next_path_position()
  var direction = global_position.direction_to(next_path_position)
  direction.y = 0
  direction = direction.normalized()
  var effective_speed = move_speed * slow_multiplier
  var target_velocity = direction * effective_speed
  velocity = velocity.lerp(target_velocity, acceleration * delta)

Direction depends on nav_agent.get_next_path_position()!
After teleport with corrupted NavigationAgent3D = STALE WAYPOINT = JITTER.

DIFFERENCE #3: Complete _process_enemy_behavior() Override
---
RangedEnemy (Lines 53-134): Completely custom implementation
BasicEnemy/TankEnemy: Use default BaseEnemy implementation (Lines 164-181)

RangedEnemy never calls handle_movement().
BasicEnemy falls back to handle_movement() after 3 seconds post-teleport.


TELEPORT TIMELINE (BaseEnemy._teleport_near_player Lines 450-487)
==================================================================

T+0.0 seconds: Teleport occurs
  Line 468: global_position = new_position (15-30m away)
  Line 469: velocity = Vector3.ZERO
  Line 474: nav_agent.target_position = target_player.global_position
  Line 479: force_direct_movement = true
  Line 480: force_direct_movement_timer = 3.0
  Line 484: navigation_ready = false
  Line 485: navigation_ready_timer = 0.1

  NavigationAgent3D now has CORRUPTED STATE:
  - Enemy was at position A, path was A -> player
  - Now at position B (15-30m away)
  - Old cached path completely wrong
  - Pathfinding system hasn't recalculated yet

T+0.1 seconds: navigation_ready becomes true
  force_direct_movement still = true (2.9 seconds remaining)
  
  RangedEnemy: Uses pure direct movement (override at Line 53)
  BasicEnemy: Uses handle_direct_movement() (Line 173, because force_direct_movement=true)

T+0.1 to T+3.0 seconds:
  Both use handle_direct_movement()
  Both WORK FINE with direct calculation
  No NavigationAgent3D queries

T+3.0 seconds: CRITICAL MOMENT - force_direct_movement expires
  force_direct_movement = false
  
  RangedEnemy: CONTINUES using pure direct movement (never changed behavior)
  
  BasicEnemy: Check Line 172 in _process_enemy_behavior():
    if move_speed >= 4.0 or force_direct_movement:
    
    move_speed = 3.0 (less than 4.0) = FALSE
    force_direct_movement = false = FALSE
    OVERALL CONDITION = FALSE
    
    Line 175: calls handle_movement()
    
    Inside handle_movement() Line 210:
      var next_path_position = nav_agent.get_next_path_position()
    
    NavigationAgent3D returns:
    - STALE WAYPOINT from old cached path
    - INCOMPLETE waypoint from recalculation
    - WRONG waypoint from path start
    
    Direction calculated to wrong waypoint
    velocity set in wrong direction
    JITTER BEGINS

T+3.0 seconds onward:
  RangedEnemy: ZERO JITTER continues indefinitely
  BasicEnemy: JITTER from corrupted NavigationAgent3D

WHY NAVIGATIONAGENT3D BECOMES CORRUPTED
========================================

1. POSITION MISMATCH:
   Enemy teleported 15-30m away. Old cached path from position A
   is completely invalid from new position B.

2. CACHED PATH NOT CLEARED:
   NavigationAgent3D caches computed paths. Teleport doesn't
   instantly invalidate all cached data.

3. ASYNCHRONOUS RECALCULATION:
   Pathfinding takes multiple frames to recalculate:
   - Frame N: Detect position changed
   - Frame N+1: Invalidate old path
   - Frame N+2: Request new path from navigation system
   - Frame N+3: Receive new path
   - Frame N+4: Update waypoint cache
   
   If get_next_path_position() called during frames N to N+3,
   returns INVALID or STALE waypoint.

4. OSCILLATION MECHANISM:
   NavAgent alternates between old cached waypoint and new waypoint
   as recalculation progresses. Enemy velocity oscillates.
   Visible as JITTER.

5. 3-SECOND WINDOW NOT ENOUGH:
   Pathfinding might take longer than 3 seconds to fully recover.
   Or nav agent might start returning jittery waypoints BEFORE
   3 seconds expire.

RANGED ENEMY'S IMMUNITY
=======================

Why RangedEnemy never jitters:

1. Never calls get_next_path_position()
   Pure math: global_position.direction_to(target_player.global_position)
   No nav agent dependency

2. Never checks is_navigation_finished()
   Only checks distance: if distance_to_player <= shoot_range

3. Calculates direction fresh EVERY FRAME
   Always points to player's CURRENT position
   Ignores NavigationAgent3D completely

4. After teleport, ALWAYS uses pure direct movement
   Never falls back to NavigationAgent3D
   Never corrupted, zero jitter

BASICENEMY/TANKENEMY VULNERABILITY
==================================

Why they jitter:

1. First 3 seconds after teleport: WORKS FINE
   force_direct_movement = true
   Uses handle_direct_movement()
   Direct calculation = correct movement

2. After 3 seconds: JITTER
   force_direct_movement = false
   Falls back to handle_movement()
   Calls nav_agent.get_next_path_position()
   NavigationAgent3D returns stale/corrupted waypoint
   Direction calculated to WRONG waypoint
   Velocity set in WRONG direction
   Enemy oscillates as nav agent updates
   VISIBLE JITTER

No safeguard to detect NavigationAgent3D state validity.


FRAME-BY-FRAME BREAKDOWN
========================

BasicEnemy After Teleport (move_speed = 3.0):

Frames 1-30 (T+0.0-0.5s): navigation_ready = false
  _process_enemy_behavior() Line 166-168:
    if not navigation_ready:
        velocity = velocity.lerp(Vector3.ZERO, acceleration * delta)
        return
  Result: No movement, velocity decelerates

Frames 31-182 (T+0.5-3.0s): navigation_ready = true, force_direct_movement = true
  _process_enemy_behavior() Line 172:
    if move_speed >= 4.0 or force_direct_movement: (TRUE)
    Line 173: handle_direct_movement(delta)
  Result: Direction = player_position, velocity accelerates toward player
  Status: WORKS FINE

Frame 183 (T+3.01s): force_direct_movement_timer expires
  force_direct_movement = false

Frames 184+ (T+3.01s onward): Critical fallback
  _process_enemy_behavior() Line 172:
    if move_speed >= 4.0 or force_direct_movement:
    move_speed = 3.0 < 4.0 = FALSE
    force_direct_movement = false = FALSE
    Condition = FALSE
  Line 175: handle_movement(delta)
  
  Inside handle_movement() Line 210:
    var next_path_position = nav_agent.get_next_path_position()
  
  NavigationAgent3D returns: STALE WAYPOINT (corrupted state)
  Direction calculated to: WRONG WAYPOINT
  Result: JITTER BEGINS - oscillates as nav agent updates

RangedEnemy After Teleport (move_speed = 2.0):

Frames 1-30: Same as BasicEnemy (also has force_direct_movement = true)
Frames 31-182: Same as BasicEnemy (both work fine during 3-second window)
Frame 183: force_direct_movement expires (same as BasicEnemy)

Frames 184+ (T+3.01s onward): NO FALLBACK
  RangedEnemy._process_enemy_behavior() override (Line 53-134)
  This function is COMPLETELY CUSTOM - doesn't use base class logic
  
  Line 124-129:
    var direction = global_position.direction_to(target_player.global_position)
    var target_velocity = direction * move_speed
    velocity = velocity.lerp(target_velocity, acceleration * delta)
  
  Pure direct calculation
  NO NavigationAgent3D query
  NO handle_movement() call
  
  Result: ZERO JITTER - continues perfectly

EXACT CODE SNIPPETS: SIDE-BY-SIDE
==================================

RANGED ENEMY DIRECT MOVEMENT (Line 123-129):

    var direction = global_position.direction_to(target_player.global_position)
    direction.y = 0
    direction = direction.normalized()
    
    var target_velocity = direction * move_speed
    velocity = velocity.lerp(target_velocity, acceleration * delta)
    
    if velocity.length() > 0.1:
        var angle = atan2(direction.x, direction.z)
        rotation.y = lerp_angle(rotation.y, angle, rotation_speed * delta)

Key: direction is calculated from CURRENT PLAYER POSITION
Dependencies: NONE - Pure math


BASIC ENEMY DEFAULT MOVEMENT (handle_movement Line 210-218):

    var next_path_position = nav_agent.get_next_path_position()
    var direction = global_position.direction_to(next_path_position)
    direction.y = 0
    direction = direction.normalized()
    
    var effective_speed = move_speed * slow_multiplier
    var target_velocity = direction * effective_speed
    velocity = velocity.lerp(target_velocity, acceleration * delta)

Then rotation applied at _process_enemy_behavior() Line 177-181:

    if velocity.length() > 0.1:
        var target_direction = velocity.normalized()
        var target_rotation = atan2(target_direction.x, target_direction.z)
        rotation.y = lerp_angle(rotation.y, target_rotation, rotation_speed * delta)

Key: direction is calculated from NAV_AGENT WAYPOINT
Dependencies: NavigationAgent3D.get_next_path_position() - CORRUPTED AFTER TELEPORT


THE SOLUTION
============

For BasicEnemy/TankEnemy to work like RangedEnemy:

OPTION 1: Override completely (RECOMMENDED)
- Override _should_update_navigation_path() to return false
- Override _process_enemy_behavior() with pure direct movement
- Never call handle_movement()
- Matches RangedEnemy architecture
- Simpler, faster, more reliable
- Zero jitter guaranteed

OPTION 2: Extend force_direct_movement duration
- Increase from 3.0 to 10+ seconds
- Fragile - depends on nav agent recovering
- Still vulnerable if recovery takes longer

OPTION 3: Add nav agent state validation
- Check path validity before querying
- Complex and potentially unreliable
- Still depends on NavigationAgent3D

RECOMMENDED: Option 1 - Match RangedEnemy approach

FILES AND LINE NUMBERS
======================

BaseEnemy.gd:
  Line 160-162: _should_update_navigation_path() default
  Line 164-181: _process_enemy_behavior() default
  Line 190-218: handle_movement()
  Line 220-239: handle_direct_movement()
  Line 450-487: _teleport_near_player()

RangedEnemy.gd:
  Line 49-51: _should_update_navigation_path() override
  Line 53-134: _process_enemy_behavior() override
  Line 123-129: Direct movement calculation

Enemy Speeds (from .tscn files):
  RangedEnemy: 2.0
  BasicEnemy: 3.0
  TankEnemy: 1.5
  FastEnemy: 4.5 (already bypasses nav agent)

